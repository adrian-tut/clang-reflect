// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cstddef>
#include <cstdint>
#include <iterator>

namespace std
{

template<std::size_t I, typename T>
struct variant_alternative_t;  

};

namespace cppx
{
namespace meta
{
inline namespace v1
{

// TODO: Keep this in sync with the compiler.
enum construct_kind {
  null_construct,

  translation_unit,
  namespace_decl,
  variable_decl,
  function_decl,
  parameter_decl,
  class_decl,
  union_decl,
  member_variable_decl,
  member_function_decl,
  constructor_decl,
  destructor_decl,
  conversion_decl,
  enum_decl,
  enumerator_decl,
  access_spec,

  void_type,
  character_type,
  integral_type,
  floating_point_type,
  reference_type,
  function_type,
  pointer_type,
  array_type,
};

enum linkage_kind {
  external_linkage,
  internal_linkage,
  no_linkage,
};

enum storage_kind {
  automatic_storage,
  thread_local_storage,
  static_storage,
};

enum access_kind {
  public_access,
  protected_access,
  private_access,
  no_access,
};

// WARNING: Do not modify the layout of this class or its private constructors
// unless you also plan to modify the compiler. In other words, do not touch.
struct meta_data
{
  immediate meta_data() 
    : category(null_construct), handle() 
  { }

  /// Returns true when this is a null reference.
  immediate bool null() const { return handle == 0; }
  
  /// FIXME: We can actually drop this member; the kind can be recovered from
  /// the reflection cache.
  unsigned category;

  /// The handle to the reflected construct.
  std::uintptr_t handle;
};

immediate bool operator==(meta_data a, meta_data b) noexcept {
  return a.handle == b.handle;
}

immediate bool operator!=(meta_data a, meta_data b) noexcept {
  return a.handle != b.handle;
}



// -------------------------------------------------------------------------- //
// Meta info variant

/// The primary interface to reflection. This models the read-only version of
/// the concept inherent in std::variant.
///
/// \todo Make private members private.
struct meta_info {
  // private:
  
  meta_data data;

  explicit immediate meta_info(meta_data md)
    : data(md)
  { }

  static constexpr meta_data null = {};

  //public:

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  /// Default construct a null reflection.
  immediate meta_info() = default;

  /// Returns the construct discriminator.
  immediate construct_kind index() const noexcept { 
    return __reflect_index(data); 
  }

  /// This never throws, so is never exceptionless.
  constexpr bool valueless_by_exception() const noexcept { 
    return false; 
  }

  immediate bool is_translation_unit() const noexcept {
    return index() == translation_unit;
  }
  immediate bool is_namespace() const noexcept {
    return index() == namespace_decl;
  }
  immediate bool is_variable() const noexcept {
    return index() == variable_decl;
  }
  immediate bool is_function() const noexcept {
    return index() == function_decl;
  }
  immediate bool is_parameter() const noexcept {
    return index() == parameter_decl;
  }
  immediate bool is_class() const noexcept {
    return index() == class_decl;
  }
  immediate bool is_union() const noexcept {
    return index() == union_decl;
  }
  immediate bool is_member_variable() const noexcept {
    return index() == member_variable_decl;
  }
  immediate bool is_member_function() const noexcept {
    return index() == member_function_decl;
  }
  immediate bool is_constructor() const noexcept {
    return index() == constructor_decl;
  }
  immediate bool is_destructor() const noexcept {
    return index() == destructor_decl;
  }
  immediate bool is_conversion() const noexcept {
    return index() == conversion_decl;
  }
  immediate bool is_enum() const noexcept {
    return index() == enum_decl;
  }
  immediate bool is_enumerator() const noexcept {
    return index() == enumerator_decl;
  }
  immediate bool is_access_specifier() const noexcept {
    return index() == access_spec;
  }

  immediate bool is_void_type() const noexcept {
    return index() == void_type;
  }
  immediate bool is_character_type() const noexcept {
    return index() == character_type;
  }
  immediate bool is_integral_type() const noexcept {
    return index() == integral_type;
  }
  immediate bool is_floating_point_type() const noexcept {
    return index() == floating_point_type;
  }
  immediate bool is_reference_type() const noexcept {
    return index() == reference_type;
  }
  immediate bool is_function_type() const noexcept {
    return index() == function_type;
  }
  immediate bool is_pointer_type() const noexcept {
    return index() == pointer_type;
  }
  immediate bool is_array_type() const noexcept {
    return index() == array_type;
  }

  // Convenience functions

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate int print() const noexcept {
    return __reflect_print(data);
  }
};

immediate bool operator==(meta_info a, meta_info b) noexcept {
  return a.data == b.data;
}

immediate bool operator!=(meta_info a, meta_info b) noexcept {
  return a.data != b.data;
}

// -------------------------------------------------------------------------- //
// Iterators

struct decl_iterator
{
  using value_type = meta_info;
  using reference = meta_info;
  using pointer = void;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  meta_info curr; // The current declaration.

  immediate decl_iterator() = default;

  immediate decl_iterator(meta_info mi)
    : curr(mi)
  { }

  immediate meta_info operator*() const noexcept {
    return curr;
  }

  immediate decl_iterator& operator++() noexcept {
    curr = __reflect_next_member(curr.data);
    return *this;
  }
  immediate decl_iterator operator++(int) noexcept {
    decl_iterator tmp = *this;
    curr = __reflect_next_member(curr.data);
    return tmp;
  }

  friend immediate bool operator==(decl_iterator a, decl_iterator b) noexcept {
    return a.curr == b.curr;
  }
  friend immediate bool operator!=(decl_iterator a, decl_iterator b) noexcept {
    return a.curr != b.curr;
  }
};

struct decl_range
{
  immediate decl_iterator begin() { return first; }
  immediate decl_iterator end() { return limit; }

  decl_iterator first;
  decl_iterator limit;
};

// -------------------------------------------------------------------------- //
// Declarations

/// Compile-time information about a translation unit.
struct translation_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate translation_info() = default;
  
  immediate translation_info(meta_info mi)
    : data(mi.is_translation_unit() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }
};

/// Compile-time information about a namespace.
struct namespace_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : is_inline(n & 0x01) 
    { }
    
    bool is_inline : 1;
  };

  immediate namespace_info() = default;
  
  immediate namespace_info(meta_info mi)
    : data(mi.is_namespace() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }

  /// Returns the traits of the translation unit.
  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  /// True if the namespace is inline,
  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }
};

/// Compile-time information about a variable.
struct variable_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        storage((n & 0x0c) >> 2),
        is_static(n & 0x10),
        is_extern(n & 0x20),
        is_constexpr(n & 0x40),
        is_inline(n & 0x80)
    { }
    
    unsigned linkage : 2;
    unsigned storage : 2;
    bool is_static : 1;
    bool is_extern : 1;
    bool is_constexpr : 1;
    bool is_inline : 1;
  };

  immediate variable_info() = default;
  
  immediate variable_info(meta_info mi)
    : data(mi.is_variable() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate storage_kind storage_duration() const {
    return storage_kind(traits().storage);
  }

  immediate bool has_static_storage() const noexcept {
    return storage_duration() == static_storage;
  }

  immediate bool has_automatic_storage() const noexcept {
    return storage_duration() == automatic_storage;
  }

  immediate bool has_thread_local_storage() const noexcept {
    return storage_duration() == thread_local_storage;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_extern() const noexcept {
    return traits().is_extern;
  }

  immediate bool is_constexpr() const noexcept {
    return traits().is_constexpr;
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }
};

/// Compile-time information about a function.
struct function_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03), 
        is_static(n & 0x04),
        is_extern(n & 0x08),
        is_constexpr(n & 0x10),
        is_defined(n & 0x20),
        is_inline(n & 0x40), 
        is_deleted(n & 0x80)
    { }
    
    unsigned linkage : 2;
    bool is_static : 1;
    bool is_extern : 1;
    bool is_constexpr : 1;
    bool is_defined : 1;
    bool is_inline : 1;
    bool is_deleted : 1;
  };

  immediate function_info() = default;

  immediate function_info(meta_info mi)
    : data(mi.is_function() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_extern() const noexcept {
    return traits().is_extern;
  }

  immediate bool is_constexpr() const noexcept {
    return traits().is_constexpr;
  }

  immediate bool is_defined() const noexcept {
    return traits().is_defined;
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }

  immediate bool is_deleted() const noexcept {
    return traits().is_deleted;
  }
};

/// Compile-time information about a parameter.
struct parameter_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate parameter_info() = default;

  immediate parameter_info(meta_info mi)
    : data(mi.is_parameter() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a class.
struct class_info {
  meta_data data;

  static constexpr bool is_reflection_type = true;

  /// FIXME: Add all computed traits.
  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2),
        is_complete(n & 0x10),
        is_polymorphic(n & 0x020),
        is_abstract(n & 0x40),
        is_final(n & 0x80),
        is_empty(n & 0x0100)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
    bool is_complete : 1;
    bool is_polymorphic : 1;
    bool is_abstract : 1;
    bool is_final : 1;
    bool is_empty : 1;
  };

  immediate class_info() = default;
  
  immediate class_info(meta_info mi)
    : data(mi.is_class() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }
  
  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  /// True if the class is complete.
  immediate bool is_complete() const noexcept {
    return traits().is_complete;
  }

  /// True if the class is polymorphic.
  immediate bool is_polymorphic() const noexcept {
    return traits().is_polymorphic;
  }

  /// True if the class is abstract.
  immediate bool is_abstract() const noexcept {
    return traits().is_abstract;
  }

  /// True if the class is final.
  immediate bool is_final() const noexcept {
    return traits().is_final;
  }

  /// True if the class is empty.
  immediate bool is_empty() const noexcept {
    return traits().is_empty;
  }
};


/// Compile-time information about a union.
struct union_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  // FIXME: Add other computed properties.
  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2),
        is_complete(n & 0x10)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
    bool is_complete : 1;
  };

  immediate union_info() = default;
  
  immediate union_info(meta_info mi)
    : data(mi.is_union() ? mi.data :  mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_complete() const noexcept {
    return traits().is_complete;
  }
};

/// Compile-time information about a member variable.
struct member_variable_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : storage(n & 0x03), 
        access((n & 0x0c) >> 2),
        is_static(n & 0x10),
        is_mutable(n & 0x20),
        is_constexpr(n & 0x40),
        is_inline(n & 0x80)
    { }
    
    unsigned storage : 2;
    unsigned access : 2;
    bool is_static : 1;
    bool is_mutable : 1;
    bool is_constexpr : 1;
    bool is_inline : 1;
  };

  immediate member_variable_info() = default;

  immediate member_variable_info(meta_info mi)
    : data(mi.is_member_variable() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate storage_kind storage_duration() const noexcept {
    return storage_kind(traits().storage);
  };

  immediate bool has_static_storage() const noexcept {
    return storage_duration() == static_storage;
  }

  immediate bool has_automatic_storage() const noexcept {
    return storage_duration() == automatic_storage;
  }

  immediate bool has_thread_local_storage() const noexcept {
    return storage_duration() == thread_local_storage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_mutable() const noexcept {
    return traits().is_mutable;
  }

  immediate bool is_constexpr() const noexcept {
    return traits().is_constexpr;
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }
};

/// Compile-time information about a member function.
struct member_function_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x3),
        is_static(n & 0x04),
        is_constexpr(n & 0x08),
        is_virtual(n & 0x10),
        is_pure(n & 0x20),
        is_override(n & 0x40),
        is_final(n & 0x80),
        is_defined(n & 0x0100),
        is_deleted(n & 0x0200),
        is_inline(n & 0x0400)
    { }

    unsigned access : 2;
    bool is_static : 1;
    bool is_constexpr : 1;
    bool is_virtual : 1;
    bool is_pure : 1;
    bool is_override : 1;
    bool is_final : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_inline : 1;
  };

  immediate member_function_info() = default;

  immediate member_function_info(meta_info mi)
    : data(mi.is_member_function() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_constexpr() const {
    return traits().is_constexpr;
  }

  immediate bool is_virtual() const {
    return traits().is_virtual;
  }

  immediate bool is_pure_virtual() const {
    return traits().is_pure;
  }

  immediate bool is_override() const {
    return traits().is_override;
  }

  immediate bool is_final() const {
    return traits().is_final;
  }

  immediate bool is_defined() const {
    return traits().is_defined;
  }

  immediate bool is_deleted() const {
    return traits().is_deleted;
  }

  immediate bool is_inline() const {
    return traits().is_inline;
  }
};

/// Compile-time information about a constructor.
struct constructor_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03),
        is_explicit(n & 0x40),
        is_constexpr(n & 0x80),
        is_defined(n & 0x0100),
        is_deleted(n & 0x0200),
        is_defaulted(n & 0x0400),
        is_inline(n & 0x0800)
    { }

    unsigned access : 2;
    bool is_explicit : 1;
    bool is_constexpr : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_defaulted : 1;
    bool is_inline : 1;
  };

  immediate constructor_info() = default;

  immediate constructor_info(meta_info mi)
    : data(mi.is_constructor() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_explicit() const {
    return traits().is_explicit;
  }

  immediate bool is_constexpr() const {
    return traits().is_constexpr;
  }

  immediate bool is_defined() const {
    return traits().is_defined;
  }

  immediate bool is_deleted() const {
    return traits().is_deleted;
  }

  immediate bool is_defaulted() const {
    return traits().is_defaulted;
  }

  immediate bool is_inline() const {
    return traits().is_inline;
  }};

/// Compile-time information about a destructor.
struct destructor_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03), 
        is_virtual(n & 0x10),
        is_pure(n & 0x20),
        is_override(n & 0x40),
        is_final(n & 0x80),
        is_defined(n & 0x0200),
        is_deleted(n & 0x0400),
        is_defaulted(n & 0x0400),
        is_inline(n & 0x0800)
    { }

    unsigned access : 2;
    bool is_virtual : 1;
    bool is_pure : 1;
    bool is_override : 1;
    bool is_final : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_defaulted : 1;
    bool is_inline : 1;
  };

  immediate destructor_info() = default;

  immediate destructor_info(meta_info mi)
    : data(mi.is_destructor() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_virtual() const {
    return traits().is_virtual;
  }

  immediate bool is_pure_virtual() const {
    return traits().is_pure;
  }

  immediate bool is_override() const {
    return traits().is_override;
  }

  immediate bool is_final() const {
    return traits().is_final;
  }

  immediate bool is_defined() const {
    return traits().is_defined;
  }

  immediate bool is_deleted() const {
    return traits().is_deleted;
  }

  immediate bool is_defaulted() const {
    return traits().is_deleted;
  }

  immediate bool is_inline() const {
    return traits().is_inline;
  }
};

/// Compile-time information about a conversion function.
struct conversion_info {
  meta_data data;

  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03),
        is_explicit(n & 0x08),
        is_constexpr(n & 0x10),
        is_virtual(n & 0x20),
        is_pure(n & 0x40),
        is_override(n & 0x80),
        is_final(n & 0x0100),
        is_defined(n & 0x0400),
        is_deleted(n & 0x0800),
        is_inline(n & 0x01000)
    { }

    unsigned access : 2;
    bool is_explicit : 1;
    bool is_constexpr : 1;
    bool is_virtual : 1;
    bool is_pure : 1;
    bool is_override : 1;
    bool is_final : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_inline : 1;
  };

  immediate conversion_info() = default;

  immediate conversion_info(meta_info mi)
    : data(mi.is_conversion() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about an enumeration.
///
/// \todo Add support for underlying type.
struct enum_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2),
        is_complete(n & 0x10),
        is_scoped(n & 0x20)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
    bool is_complete : 1;
    bool is_scoped : 1;
  };

  immediate enum_info() = default;
  
  immediate enum_info(meta_info mi)
    : data(mi.is_enum() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_complete() const noexcept {
    return traits().is_complete;
  }

  immediate bool is_scoped() const noexcept {
    return traits().is_scoped;
  }
};

/// Compile-time information about an enumerator.
struct enumerator_info {
  meta_data data;

  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
  };

  immediate enumerator_info() = default;

  immediate enumerator_info(meta_info mi)
    : data(mi.is_enumerator() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }
};

/// Compile-time information about an access specifier.
struct access_info {
  meta_data data;

  static constexpr bool is_reflection_type = true;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03)
    { }
    
    unsigned access : 2;
  };

  immediate access_info() = default;

  immediate access_info(meta_info mi)
    : data(mi.is_access_specifier() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  }

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }
};


// -------------------------------------------------------------------------- //
// Types

/// Compile-time information about the void type.
struct void_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate void_type_info() = default;

  immediate void_type_info(meta_info mi)
    : data(mi.is_void_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a character type.
struct character_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate character_type_info() = default;

  immediate character_type_info(meta_info mi)
    : data(mi.is_character_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about an integral type.
struct integral_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate integral_type_info() = default;

  immediate integral_type_info(meta_info mi)
    : data(mi.is_integral_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a floating point type.
struct floating_point_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate floating_point_type_info() = default;

  immediate floating_point_type_info(meta_info mi)
    : data(mi.is_floating_point_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a reference type.
struct reference_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate reference_type_info() = default;

  immediate reference_type_info(meta_info mi)
    : data(mi.is_reference_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a function type.
struct function_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate function_type_info() = default;

  immediate function_type_info(meta_info mi)
    : data(mi.is_function_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a pointer type.
struct pointer_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate pointer_type_info() = default;

  immediate pointer_type_info(meta_info mi)
    : data(mi.is_pointer_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a array type.
struct array_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate array_type_info() = default;

  immediate array_type_info(meta_info mi)
    : data(mi.is_array_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};


// -------------------------------------------------------------------------- //
// Utilities

struct compiler_type {
  static immediate void print(const char* str) noexcept {
    (void)__reflect_print(str);
  }

  template<typename T>
  static immediate std::enable_if_t<std::is_integral_v<T>, void>
  print(T n) noexcept {
    (void)__reflect_print(n);
  }

  // Specialization for reflected types.
  template<typename T>
  static immediate std::enable_if_t<T::is_reflection_type, void>
  print(T info) noexcept {
    (void)__reflect_print(info.data);
  }

} compiler;


} // inline namespace v1
} // namespace meta
} // namespace cppx



#endif // CPPX_META
