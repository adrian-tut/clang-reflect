// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cstddef>
#include <cstdint>

namespace cppx
{
namespace meta
{
inline namespace v1
{

// TODO: Keep this in sync with the compiler.
enum construct_kind {
  null_construct,

  translation_unit,
  namespace_decl,
  variable_decl,
  member_variable_decl,
  function_decl,
  parameter_decl,
  member_function_decl,
  constructor_decl,
  destructor_decl,
  conversion_decl,
  enumerator_decl,
  access_spec,

  void_type,
  character_type,
  integral_type,
  floating_point_type,
  reference_type,
  function_type,
  pointer_type,
  array_type,
  class_type,
  union_type,
  enum_type,
};

namespace __detail {

// WARNING: Do not modify the layout of this class or its private constructors
// unless you also plan to modify the compiler. In other words, do not touch.
struct meta_data
{
  constexpr meta_data() 
    : category(null_construct), handle() 
  { }
  
  unsigned category;
  std::uintptr_t handle;
};

} // namespace __detail

/// The primary interface to reflection. This models the read-only version of
/// the concept inherent in std::variant.
class meta_info 
{
  __detail::meta_data m;
public:
  /// Default construct a null reflection.
  constexpr meta_info() = default;

  /// Returns the construct discriminator.
  immediate std::size_t index() const noexcept { 
    return __reflect_index(m); 
  }

  // This is never valueless.
  constexpr bool valueless_by_exception() const noexcept { 
    return false; 
  }
};

} // inline namespace v1
} // namespace meta
} // namespace cppx



#endif // CPPX_META
