// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cstddef>
#include <cstdint>
#include <iterator>

namespace std
{

template<std::size_t I, typename T>
struct variant_alternative_t;  

};

namespace cppx
{
namespace meta
{
inline namespace v1
{

// TODO: Keep this in sync with the compiler.
enum construct_kind {
  null_construct,

  translation_unit,
  namespace_decl,
  variable_decl,
  function_decl,
  parameter_decl,
  class_decl,
  union_decl,
  member_variable_decl,
  member_function_decl,
  constructor_decl,
  destructor_decl,
  conversion_decl,
  enum_decl,
  enumerator_decl,
  access_spec,

  void_type,
  character_type,
  integral_type,
  floating_point_type,
  reference_type,
  function_type,
  pointer_type,
  array_type,
};

// WARNING: Do not modify the layout of this class or its private constructors
// unless you also plan to modify the compiler. In other words, do not touch.
struct meta_data
{
  immediate meta_data() 
    : category(null_construct), handle() 
  { }

  /// Returns true when this is a null reference.
  immediate bool null() const { return handle == 0; }
  
  /// FIXME: We can actually drop this member; the kind can be recovered from
  /// the reflection cache.
  unsigned category;

  /// The handle to the reflected construct.
  std::uintptr_t handle;
};

immediate bool operator==(meta_data a, meta_data b) noexcept {
  return a.handle == b.handle;
}

immediate bool operator!=(meta_data a, meta_data b) noexcept {
  return a.handle != b.handle;
}



// -------------------------------------------------------------------------- //
// Meta info variant

/// The primary interface to reflection. This models the read-only version of
/// the concept inherent in std::variant.
///
/// \todo Make private members private.
struct meta_info {
  // private:
  
  meta_data data;

  explicit immediate meta_info(meta_data md)
    : data(md)
  { }

  static constexpr meta_data null = {};

  //public:

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  /// Default construct a null reflection.
  immediate meta_info() = default;

  /// Returns the construct discriminator.
  immediate construct_kind index() const noexcept { 
    return __reflect_index(data); 
  }

  /// This never throws, so is never exceptionless.
  constexpr bool valueless_by_exception() const noexcept { 
    return false; 
  }

  immediate bool is_translation_unit() const noexcept {
    return index() == translation_unit;
  }
  immediate bool is_namespace() const noexcept {
    return index() == namespace_decl;
  }
  immediate bool is_variable() const noexcept {
    return index() == variable_decl;
  }
  immediate bool is_function() const noexcept {
    return index() == function_decl;
  }
  immediate bool is_parameter() const noexcept {
    return index() == parameter_decl;
  }
  immediate bool is_class() const noexcept {
    return index() == class_decl;
  }
  immediate bool is_union() const noexcept {
    return index() == union_decl;
  }
  immediate bool is_member_variable() const noexcept {
    return index() == member_variable_decl;
  }
  immediate bool is_member_function() const noexcept {
    return index() == member_function_decl;
  }
  immediate bool is_constructor() const noexcept {
    return index() == constructor_decl;
  }
  immediate bool is_destructor() const noexcept {
    return index() == destructor_decl;
  }
  immediate bool is_conversion() const noexcept {
    return index() == conversion_decl;
  }
  immediate bool is_enum() const noexcept {
    return index() == enum_decl;
  }
  immediate bool is_enumerator() const noexcept {
    return index() == enumerator_decl;
  }
  immediate bool is_access_specifier() const noexcept {
    return index() == access_spec;
  }

  immediate bool is_void_type() const noexcept {
    return index() == void_type;
  }
  immediate bool is_character_type() const noexcept {
    return index() == character_type;
  }
  immediate bool is_integral_type() const noexcept {
    return index() == integral_type;
  }
  immediate bool is_floating_point_type() const noexcept {
    return index() == floating_point_type;
  }
  immediate bool is_reference_type() const noexcept {
    return index() == reference_type;
  }
  immediate bool is_function_type() const noexcept {
    return index() == function_type;
  }
  immediate bool is_pointer_type() const noexcept {
    return index() == pointer_type;
  }
  immediate bool is_array_type() const noexcept {
    return index() == array_type;
  }

  // Convenience functions

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate int print() const noexcept {
    return __reflect_print(data);
  }
};

immediate bool operator==(meta_info a, meta_info b) noexcept {
  return a.data == b.data;
}

immediate bool operator!=(meta_info a, meta_info b) noexcept {
  return a.data != b.data;
}

// -------------------------------------------------------------------------- //
// Iterators

struct decl_iterator
{
  using value_type = meta_info;
  using reference = meta_info;
  using pointer = void;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  meta_info curr; // The current declaration.

  immediate decl_iterator() = default;

  immediate decl_iterator(meta_info mi)
    : curr(mi)
  { }

  immediate meta_info operator*() const noexcept {
    return curr;
  }

  immediate decl_iterator& operator++() noexcept {
    curr = __reflect_next_member(curr.data);
    return *this;
  }
  immediate decl_iterator operator++(int) noexcept {
    decl_iterator tmp = *this;
    curr = __reflect_next_member(curr.data);
    return tmp;
  }

  friend immediate bool operator==(decl_iterator a, decl_iterator b) noexcept {
    return a.curr == b.curr;
  }
  friend immediate bool operator!=(decl_iterator a, decl_iterator b) noexcept {
    return a.curr != b.curr;
  }
};

struct decl_range
{
  immediate decl_iterator begin() { return first; }
  immediate decl_iterator end() { return limit; }

  decl_iterator first;
  decl_iterator limit;
};

// -------------------------------------------------------------------------- //
// Declarations

/// Compile-time information about a translation unit.
struct translation_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate translation_info() = default;
  
  immediate translation_info(meta_info mi)
    : data(mi.is_translation_unit() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }
};

/// Compile-time information about a namespace.
struct namespace_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate namespace_info() = default;
  
  immediate namespace_info(meta_info mi)
    : data(mi.is_namespace() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }
};

/// Compile-time information about a variable.
struct variable_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate variable_info() = default;
  
  immediate variable_info(meta_info mi)
    : data(mi.is_variable() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a function.
struct function_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate function_info() = default;

  immediate function_info(meta_info mi)
    : data(mi.is_function() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a parameter.
struct parameter_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate parameter_info() = default;

  immediate parameter_info(meta_info mi)
    : data(mi.is_parameter() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a class.
struct class_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate class_info() = default;
  
  immediate class_info(meta_info mi)
    : data(mi.is_class() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }
};

/// Compile-time information about a union.
struct union_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate union_info() = default;
  
  immediate union_info(meta_info mi)
    : data(mi.is_union() ? mi.data :  mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }
};

/// Compile-time information about a member variable.
struct member_variable_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate member_variable_info() = default;

  immediate member_variable_info(meta_info mi)
    : data(mi.is_member_variable() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a member function.
struct member_function_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate member_function_info() = default;

  immediate member_function_info(meta_info mi)
    : data(mi.is_member_function() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a constructor.
struct constructor_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate constructor_info() = default;

  immediate constructor_info(meta_info mi)
    : data(mi.is_constructor() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a destructor.
struct destructor_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate destructor_info() = default;

  immediate destructor_info(meta_info mi)
    : data(mi.is_destructor() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about a conversion function.
struct conversion_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate conversion_info() = default;

  immediate conversion_info(meta_info mi)
    : data(mi.is_conversion() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about an enumeration.
struct enum_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate enum_info() = default;
  
  immediate enum_info(meta_info mi)
    : data(mi.is_enum() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the nested members of the entity.
  immediate decl_range members() const noexcept {
    return {decl_iterator(__reflect_first_member(data)), decl_iterator()};
  }
};

/// Compile-time information about an enumerator.
struct enumerator_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate enumerator_info() = default;

  immediate enumerator_info(meta_info mi)
    : data(mi.is_enumerator() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  /// Returns the type of the entity.
  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about an access specifier.
struct access_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate access_info() = default;

  immediate access_info(meta_info mi)
    : data(mi.is_access_specifier() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }
};


// -------------------------------------------------------------------------- //
// Types

/// Compile-time information about the void type.
struct void_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate void_type_info() = default;

  immediate void_type_info(meta_info mi)
    : data(mi.is_void_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a character type.
struct character_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate character_type_info() = default;

  immediate character_type_info(meta_info mi)
    : data(mi.is_character_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about an integral type.
struct integral_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate integral_type_info() = default;

  immediate integral_type_info(meta_info mi)
    : data(mi.is_integral_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a floating point type.
struct floating_point_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate floating_point_type_info() = default;

  immediate floating_point_type_info(meta_info mi)
    : data(mi.is_floating_point_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a reference type.
struct reference_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate reference_type_info() = default;

  immediate reference_type_info(meta_info mi)
    : data(mi.is_reference_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a function type.
struct function_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate function_type_info() = default;

  immediate function_type_info(meta_info mi)
    : data(mi.is_function_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a pointer type.
struct pointer_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate pointer_type_info() = default;

  immediate pointer_type_info(meta_info mi)
    : data(mi.is_pointer_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a array type.
struct array_type_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr bool is_reflection_type = true;

  immediate array_type_info() = default;

  immediate array_type_info(meta_info mi)
    : data(mi.is_array_type() ? mi.data : mi.null)
  { }

  /// Converts to true when the object has a value.
  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  /// Returns true when the object is non-null.
  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  /// Returns the name of the entity.
  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};


// -------------------------------------------------------------------------- //
// Utilities

struct compiler_type {
  static immediate void print(const char* str) noexcept {
    (void)__reflect_print(str);
  }

  template<typename T>
  static immediate std::enable_if_t<std::is_integral_v<T>, void>
  print(T n) noexcept {
    (void)__reflect_print(n);
  }

  // Specialization for reflected types.
  template<typename T>
  static immediate std::enable_if_t<T::is_reflection_type, void>
  print(T info) noexcept {
    (void)__reflect_print(info.data);
  }

} compiler;


} // inline namespace v1
} // namespace meta
} // namespace cppx



#endif // CPPX_META
