// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cstddef>
#include <cstdint>

namespace std
{

template<std::size_t I, typename T>
struct variant_alternative_t;  

};

namespace cppx
{
namespace meta
{
inline namespace v1
{

// TODO: Keep this in sync with the compiler.
enum construct_kind {
  null_construct,

  translation_unit,
  namespace_decl,
  variable_decl,
  function_decl,
  parameter_decl,
  class_decl,
  union_decl,
  member_variable_decl,
  member_function_decl,
  constructor_decl,
  destructor_decl,
  conversion_decl,
  enum_decl,
  enumerator_decl,
  access_spec,

  void_type,
  character_type,
  integral_type,
  floating_point_type,
  reference_type,
  function_type,
  pointer_type,
  array_type,
};

namespace detail {

// WARNING: Do not modify the layout of this class or its private constructors
// unless you also plan to modify the compiler. In other words, do not touch.
struct meta_data
{
  constexpr meta_data() 
    : category(null_construct), handle() 
  { }
  
  /// FIXME: We can actually drop this member; the kind can be recovered from
  /// the reflection cache.
  unsigned category;

  /// The handle to the reflected construct.
  std::uintptr_t handle;
};


// -------------------------------------------------------------------------- //
// Facets

/// Supports conversion to bool.
template<typename Derived>
struct nullable {
  /// Converts to true if the object has been default constructed.
  immediate explicit operator bool() const noexcept {
    const Derived& self = static_cast<const Derived&>(*this);
    return self.m.handle != 0;
  }
};

/// Provides information about the name of an entity.
template<typename Derived>
struct named {
  immediate const char* name() const noexcept {
    const Derived& self = static_cast<const Derived&>(*this);
    return __reflect_name(self.m);
  }
};


} // namespace detail

// -------------------------------------------------------------------------- //
// Declarations

/// Compile-time information about a translation unit.
class translation_info {
  detail::meta_data m;

  friend class meta_info;

  constexpr translation_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a namespace.
class namespace_info {
  detail::meta_data m;

  friend class meta_info;

  namespace_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a variable.
class variable_info : public detail::nullable<variable_info>,
                      public detail::named<variable_info> {
  detail::meta_data m;

  friend class meta_info;
  friend class nullable<variable_info>;
  friend class named<variable_info>;

  constexpr variable_info() : m() { }
  constexpr variable_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a function.
class function_info {
  detail::meta_data m;

  friend class meta_info;

  function_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a class.
class class_info : public detail::nullable<class_info>, 
                   public detail::named<class_info> {
  detail::meta_data m;

  friend class meta_info;
  friend class nullable<class_info>;
  friend class named<class_info>;

  constexpr class_info() : m() { }
  constexpr class_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a union.
class union_info : public detail::nullable<union_info>, 
                   public detail::named<union_info> {
  detail::meta_data m;

  friend class meta_info;
  friend class nullable<union_info>;
  friend class named<union_info>;

  constexpr union_info() : m() { }
  constexpr union_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a member variable.
class member_variable_info {
  detail::meta_data m;

  friend class meta_info;

  member_variable_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a member function.
class member_function_info {
  detail::meta_data m;

  friend class meta_info;

  member_function_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a constructor.
class constructor_info {
  detail::meta_data m;

  friend class meta_info;

  constructor_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a destructor.
class destructor_info {
  detail::meta_data m;

  friend class meta_info;

  destructor_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about a conversion function.
class conversion_info {
  detail::meta_data m;

  friend class meta_info;

  conversion_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about an enumeration.
class enum_info : public detail::nullable<enum_info>,
                  public detail::named<enum_info> {
  detail::meta_data m;

  friend class meta_info;
  friend class nullable<enum_info>;

  constexpr enum_info() : m() { }
  constexpr enum_info(detail::meta_data m) : m(m) { }
public:
  constexpr explicit operator bool() const noexcept { 
    return m.category != null_construct; 
  }
};

/// Compile-time information about an enumerator.
class enumerator_info {
  detail::meta_data m;

  friend class meta_info;

  enumerator_info(detail::meta_data m) : m(m) { }
public:
};

/// Compile-time information about an access specifier.
class access_info {
  detail::meta_data m;

  friend class meta_info;

  access_info(detail::meta_data m) : m(m) { }
public:
};


// -------------------------------------------------------------------------- //
// Types

/// Compile-time information about the void type...
///
/// FIXME: this does not seem particularly useful.
class void_type_info {
  detail::meta_data m;
public:
};

/// Compile-time information about an integral type.
class integral_type_info {
  detail::meta_data m;
public:
};

/// Compile-time information about a floating point type.
class floating_point_type_info {
  detail::meta_data m;
public:
};

/// Compile-time information about a reference type.
class reference_type_info {
  detail::meta_data m;
public:
};

/// Compile-time information about a function type.
class function_type_info {
  detail::meta_data m;
public:
};

/// Compile-time information about a pointer type.
class pointer_type_info {
  detail::meta_data m;
public:
};

/// Compile-time information about a array type.
class array_type_info {
  detail::meta_data m;
public:
};

// -------------------------------------------------------------------------- //
// Variant
/// The primary interface to reflection. This models the read-only version of
/// the concept inherent in std::variant.
class meta_info 
{
  detail::meta_data m;
public:
  /// Default construct a null reflection.
  constexpr meta_info() = default;

  /// Returns the construct discriminator.
  immediate std::size_t index() const noexcept { 
    return __reflect_index(m); 
  }

  // This is never valueless.
  constexpr bool valueless_by_exception() const noexcept { 
    return false; 
  }

  immediate bool is_variable() const noexcept {
    return index() == variable_decl;
  }

  immediate bool is_class() const noexcept {
    return index() == class_decl;
  }
  immediate bool is_union() const noexcept {
    return index() == union_decl;
  }
  immediate bool is_enum() const noexcept {
    return index() == enum_decl;
  }


  immediate variable_info get_variable() const noexcept {
    return is_variable() ? variable_info{m} : variable_info{};
  }

  immediate class_info get_class() const noexcept {
    return is_class() ? class_info{m} : class_info{};
  }
  immediate union_info get_union() const noexcept {
    return is_union() ? union_info{m} : union_info{};
  }
  immediate enum_info get_enum() const noexcept {
    return is_enum() ? enum_info{m} : enum_info{};
  }
};

} // inline namespace v1
} // namespace meta
} // namespace cppx



#endif // CPPX_META
