// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cstddef>
#include <cstdint>
#include <iterator>

namespace std
{

template<std::size_t I, typename T>
struct variant_alternative_t;  

};

namespace cppx
{
namespace meta
{
inline namespace v1
{

// TODO: Keep this in sync with the compiler.
enum construct_kind {
  any_construct = -1, // The static index of meta_info.

  null_construct = 0, // Never a static index.

  translation_unit,
  namespace_decl,
  variable_decl,
  function_decl,
  parameter_decl,
  class_decl,
  union_decl,
  member_variable_decl,
  member_function_decl,
  constructor_decl,
  destructor_decl,
  conversion_decl,
  enum_decl,
  enumerator_decl,
  access_spec,

  void_type,
  character_type,
  integral_type,
  floating_point_type,
  reference_type,
  function_type,
  pointer_type,
  array_type,
};

/// The meta_info alternative corresponding to the kind. Defined below.
template<construct_kind K>
struct construct_type;

template<construct_kind K>
using construct_type_t = typename construct_type<K>::type;

enum linkage_kind {
  external_linkage,
  internal_linkage,
  no_linkage,
};

enum storage_kind {
  automatic_storage,
  thread_local_storage,
  static_storage,
};

enum access_kind {
  public_access,
  protected_access,
  private_access,
  no_access,
};


// WARNING: Do not modify the layout of this class or its private constructors
// unless you also plan to modify the compiler. In other words, do not touch.
struct meta_data
{
  immediate meta_data() 
    : category(null_construct), handle() 
  { }

  /// Returns true when this is a null reference.
  immediate bool null() const { return handle == 0; }
  
  /// FIXME: We can actually drop this member; the kind can be recovered from
  /// the reflection cache.
  unsigned category;

  /// The handle to the reflected construct.
  std::uintptr_t handle;
};

immediate bool operator==(meta_data a, meta_data b) noexcept {
  return a.handle == b.handle;
}

immediate bool operator!=(meta_data a, meta_data b) noexcept {
  return a.handle != b.handle;
}


// -------------------------------------------------------------------------- //
// Meta info variant

/// The primary interface to reflection. This models the read-only version of
/// the concept inherent in std::variant.
///
/// \todo Make private members private.
struct meta_info {
  // private:
  
  meta_data data;

  explicit immediate meta_info(meta_data md)
    : data(md)
  { }

  static constexpr meta_data null = {};

  //public:

  static constexpr construct_kind construct = any_construct;

  immediate meta_info() = default;

  immediate construct_kind index() const noexcept { 
    return __reflect_index(data); 
  }

  /// This never throws, so is never exceptionless.
  constexpr bool valueless_by_exception() const noexcept { 
    return false; 
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept {
    return !data.null(); 
  }

  immediate bool is_translation_unit() const noexcept {
    return index() == translation_unit;
  }
  immediate bool is_namespace() const noexcept {
    return index() == namespace_decl;
  }
  immediate bool is_variable() const noexcept {
    return index() == variable_decl;
  }
  immediate bool is_function() const noexcept {
    return index() == function_decl;
  }
  immediate bool is_parameter() const noexcept {
    return index() == parameter_decl;
  }
  immediate bool is_class() const noexcept {
    return index() == class_decl;
  }
  immediate bool is_union() const noexcept {
    return index() == union_decl;
  }
  immediate bool is_member_variable() const noexcept {
    return index() == member_variable_decl;
  }
  immediate bool is_member_function() const noexcept {
    return index() == member_function_decl;
  }
  immediate bool is_constructor() const noexcept {
    return index() == constructor_decl;
  }
  immediate bool is_destructor() const noexcept {
    return index() == destructor_decl;
  }
  immediate bool is_conversion() const noexcept {
    return index() == conversion_decl;
  }
  immediate bool is_enum() const noexcept {
    return index() == enum_decl;
  }
  immediate bool is_enumerator() const noexcept {
    return index() == enumerator_decl;
  }
  immediate bool is_access_specifier() const noexcept {
    return index() == access_spec;
  }

  immediate bool is_void_type() const noexcept {
    return index() == void_type;
  }
  immediate bool is_character_type() const noexcept {
    return index() == character_type;
  }
  immediate bool is_integral_type() const noexcept {
    return index() == integral_type;
  }
  immediate bool is_floating_point_type() const noexcept {
    return index() == floating_point_type;
  }
  immediate bool is_reference_type() const noexcept {
    return index() == reference_type;
  }
  immediate bool is_function_type() const noexcept {
    return index() == function_type;
  }
  immediate bool is_pointer_type() const noexcept {
    return index() == pointer_type;
  }
  immediate bool is_array_type() const noexcept {
    return index() == array_type;
  }

  // Convenience functions

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

immediate bool operator==(meta_info a, meta_info b) noexcept {
  return a.data == b.data;
}

immediate bool operator!=(meta_info a, meta_info b) noexcept {
  return a.data != b.data;
}

// -------------------------------------------------------------------------- //
// Iterators

struct member_iterator
{
  using value_type = meta_info;
  using reference = meta_info;
  using pointer = void;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  meta_info curr; // The current declaration.

  immediate member_iterator() = default;

  immediate member_iterator(meta_info mi)
    : curr(__reflect_first_member(mi.data))
  { }

  immediate meta_info operator*() const noexcept {
    return curr;
  }

  immediate member_iterator& operator++() noexcept {
    curr = __reflect_next_member(curr.data);
    return *this;
  }
  immediate member_iterator operator++(int) noexcept {
    member_iterator tmp = *this;
    curr = __reflect_next_member(curr.data);
    return tmp;
  }

  friend immediate bool operator==(member_iterator a, member_iterator b) noexcept {
    return a.curr == b.curr;
  }
  friend immediate bool operator!=(member_iterator a, member_iterator b) noexcept {
    return a.curr != b.curr;
  }
};

struct member_range
{
  using iterator = member_iterator;

  immediate member_range(meta_info mi)
    : first(mi), limit()
  { }

  immediate iterator begin() const noexcept { 
    return first; 
  }
  immediate iterator end() const noexcept { 
    return limit; 
  }

  iterator first;
  iterator limit;
};

/// Iterates over members of a particular kind.
template<typename Info>
struct specific_member_iterator
{
  using value_type = meta_info;
  using reference = meta_info;
  using pointer = void;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  member_iterator iter; // The current iterator.

  immediate specific_member_iterator() = default;

  immediate specific_member_iterator(meta_info mi)
    : iter(mi)
  {
    advance();
  }

  immediate meta_info operator*() const noexcept {
    return *iter;
  }

  immediate specific_member_iterator& operator++() noexcept {
    ++iter;
    advance();
    return *this;
  }
  immediate specific_member_iterator operator++(int) noexcept {
    specific_member_iterator tmp = *this;
    ++iter;
    return tmp;
  }

  friend immediate bool 
  operator==(specific_member_iterator a, specific_member_iterator b) noexcept {
    return a.iter == b.iter;
  }
  friend immediate bool 
  operator!=(specific_member_iterator a, specific_member_iterator b) noexcept {
    return a.iter != b.iter;
  }

  immediate void advance() {
    if (Info::construct != any_construct) {
      while (*iter && (*iter).index() != Info::construct)
        ++iter;
    }
  }
};

template<typename Info>
struct specific_member_range
{
  using iterator = specific_member_iterator<Info>;

  immediate specific_member_range(meta_info mi)
    : first(mi), limit()
  { }

  immediate iterator begin() const noexcept { 
    return first; 
  }
  immediate iterator end() const noexcept { 
    return limit; 
  }

  iterator first;
  iterator limit;
};

/// Iterates over members of a particular kind.
template<typename Pred>
struct filter_member_iterator
{
  using value_type = meta_info;
  using reference = meta_info;
  using pointer = void;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  member_iterator iter; // The current iterator.
  Pred pred; // The predicate

  immediate filter_member_iterator(Pred p = {})
    : iter(), pred(p)
  { }
  immediate filter_member_iterator(meta_info mi, Pred p = {})
    : iter(mi), pred(p)
  { advance(); }

  immediate meta_info operator*() const noexcept {
    return *iter;
  }

  immediate filter_member_iterator& operator++() noexcept {
    ++iter;
    advance();
    return *this;
  }
  immediate filter_member_iterator operator++(int) noexcept {
    filter_member_iterator tmp = *this;
    ++iter;
    return tmp;
  }

  friend immediate bool 
  operator==(filter_member_iterator a, filter_member_iterator b) noexcept {
    return a.iter == b.iter;
  }
  friend immediate bool 
  operator!=(filter_member_iterator a, filter_member_iterator b) noexcept {
    return a.iter != b.iter;
  }

  immediate void advance() {
    while (*iter && !pred(*iter))
      ++iter;
  }
};

template<typename Pred>
struct filter_member_range
{
  using iterator = filter_member_iterator<Pred>;

  immediate filter_member_range(meta_info mi, Pred p = {})
    : first(mi, p), limit(p)
  { }

  immediate iterator begin() const noexcept { 
    return first; 
  }
  immediate iterator end() const noexcept { 
    return limit; 
  }

  iterator first;
  iterator limit;
};



// -------------------------------------------------------------------------- //
// Declarations

/// Compile-time information about a translation unit.
struct translation_info {
  meta_data data;

  static constexpr construct_kind construct = translation_unit;

  immediate translation_info() = default;
  
  immediate translation_info(meta_info mi)
    : data(mi.is_translation_unit() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate member_range members() const noexcept {
    return {*this};
  }
};

/// Compile-time information about a namespace.
struct namespace_info {
  meta_data data;

  static constexpr construct_kind construct = namespace_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : is_inline(n & 0x01) 
    { }
    
    bool is_inline : 1;
  };

  immediate namespace_info() = default;
  
  immediate namespace_info(meta_info mi)
    : data(mi.is_namespace() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate member_range members() const noexcept {
    return {*this};
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }
};

/// Compile-time information about a variable.
struct variable_info {
  meta_data data;

  static constexpr construct_kind construct = variable_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        storage((n & 0x0c) >> 2),
        is_static(n & 0x10),
        is_extern(n & 0x20),
        is_constexpr(n & 0x40),
        is_inline(n & 0x80)
    { }
    
    unsigned linkage : 2;
    unsigned storage : 2;
    bool is_static : 1;
    bool is_extern : 1;
    bool is_constexpr : 1;
    bool is_inline : 1;
  };

  immediate variable_info() = default;
  
  immediate variable_info(meta_info mi)
    : data(mi.is_variable() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate storage_kind storage_duration() const {
    return storage_kind(traits().storage);
  }

  immediate bool has_static_storage() const noexcept {
    return storage_duration() == static_storage;
  }

  immediate bool has_automatic_storage() const noexcept {
    return storage_duration() == automatic_storage;
  }

  immediate bool has_thread_local_storage() const noexcept {
    return storage_duration() == thread_local_storage;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_extern() const noexcept {
    return traits().is_extern;
  }

  immediate bool is_constexpr() const noexcept {
    return traits().is_constexpr;
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }

  template<typename T>
  immediate T& get() const noexcept {
    T* addr{};
    (void)__reflect_address(data, addr);
    return *addr;
  }
};

/// Compile-time information about a function.
struct function_info {
  meta_data data;

  static constexpr construct_kind construct = function_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03), 
        is_static(n & 0x04),
        is_extern(n & 0x08),
        is_constexpr(n & 0x10),
        is_defined(n & 0x20),
        is_inline(n & 0x40), 
        is_deleted(n & 0x80)
    { }
    
    unsigned linkage : 2;
    bool is_static : 1;
    bool is_extern : 1;
    bool is_constexpr : 1;
    bool is_defined : 1;
    bool is_inline : 1;
    bool is_deleted : 1;
  };

  immediate function_info() = default;

  immediate function_info(meta_info mi)
    : data(mi.is_function() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_extern() const noexcept {
    return traits().is_extern;
  }

  immediate bool is_constexpr() const noexcept {
    return traits().is_constexpr;
  }

  immediate bool is_defined() const noexcept {
    return traits().is_defined;
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }

  immediate bool is_deleted() const noexcept {
    return traits().is_deleted;
  }

  template<typename T>
  immediate T& get() const noexcept {
    T* addr{};
    (void)__reflect_address(data, addr);
    return *addr;
  }
};

/// Compile-time information about a parameter.
struct parameter_info {
  meta_data data;

  static constexpr construct_kind construct = parameter_decl;

  immediate parameter_info() = default;

  immediate parameter_info(meta_info mi)
    : data(mi.is_parameter() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

struct member_variable_info;
struct member_function_info;
struct constructor_info;
struct destructor_info;
struct conversion_info;

struct is_member_variable_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_instance_variable_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_class_variable_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_member_function_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_instance_function_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_class_function_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_constructor_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

struct is_destructor_p
{
  immediate bool operator()(meta_info mi) const noexcept;
};

using memvar_range = filter_member_range<is_member_variable_p>;
using instance_memvar_range = filter_member_range<is_instance_variable_p>;
using class_memvar_range = filter_member_range<is_class_variable_p>;

using memfun_range = filter_member_range<is_member_function_p>;
using instance_memfun_range = filter_member_range<is_instance_function_p>;
using constructor_range = filter_member_range<is_constructor_p>;
using destructor_range = filter_member_range<is_destructor_p>;
using class_memfun_range = filter_member_range<is_class_function_p>;


/// Compile-time information about a class.
struct class_info {
  meta_data data;

  static constexpr construct_kind construct = class_decl;

  /// FIXME: Add all computed traits.
  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2),
        is_complete(n & 0x10),
        is_polymorphic(n & 0x020),
        is_abstract(n & 0x40),
        is_final(n & 0x80),
        is_empty(n & 0x0100)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
    bool is_complete : 1;
    bool is_polymorphic : 1;
    bool is_abstract : 1;
    bool is_final : 1;
    bool is_empty : 1;
  };

  immediate class_info() = default;
  
  immediate class_info(meta_info mi)
    : data(mi.is_class() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate member_range members() const noexcept {
    return {*this};
  }

  immediate memvar_range all_member_variables() const noexcept;
  immediate instance_memvar_range member_variables() const noexcept;
  immediate class_memvar_range static_member_variables() const noexcept;
  
  immediate memfun_range all_member_functions() const noexcept;
  immediate instance_memfun_range member_functions() const noexcept;
  immediate constructor_range constructors() const noexcept;
  immediate destructor_range destructors() const noexcept;
  immediate class_memfun_range static_member_functions() const noexcept;

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_complete() const noexcept {
    return traits().is_complete;
  }

  immediate bool is_polymorphic() const noexcept {
    return traits().is_polymorphic;
  }

  immediate bool is_abstract() const noexcept {
    return traits().is_abstract;
  }

  immediate bool is_final() const noexcept {
    return traits().is_final;
  }

  immediate bool is_empty() const noexcept {
    return traits().is_empty;
  }
};


/// Compile-time information about a union.
struct union_info {
  meta_data data;

  /// Denotes that this is a reflection.
  static constexpr construct_kind construct = union_decl;

  // FIXME: Add other computed properties.
  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2),
        is_complete(n & 0x10)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
    bool is_complete : 1;
  };

  immediate union_info() = default;
  
  immediate union_info(meta_info mi)
    : data(mi.is_union() ? mi.data :  mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate member_range members() const noexcept {
    return {*this};
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_complete() const noexcept {
    return traits().is_complete;
  }
};

/// Compile-time information about a member variable.
struct member_variable_info {
  meta_data data;

  static constexpr construct_kind construct = member_variable_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : storage(n & 0x03), 
        access((n & 0x0c) >> 2),
        is_static(n & 0x10),
        is_mutable(n & 0x20),
        is_constexpr(n & 0x40),
        is_inline(n & 0x80)
    { }
    
    unsigned storage : 2;
    unsigned access : 2;
    bool is_static : 1;
    bool is_mutable : 1;
    bool is_constexpr : 1;
    bool is_inline : 1;
  };

  immediate member_variable_info() = default;

  immediate member_variable_info(meta_info mi)
    : data(mi.is_member_variable() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate storage_kind storage_duration() const noexcept {
    return storage_kind(traits().storage);
  };

  immediate bool has_static_storage() const noexcept {
    return storage_duration() == static_storage;
  }

  immediate bool has_automatic_storage() const noexcept {
    return storage_duration() == automatic_storage;
  }

  immediate bool has_thread_local_storage() const noexcept {
    return storage_duration() == thread_local_storage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_mutable() const noexcept {
    return traits().is_mutable;
  }

  immediate bool is_constexpr() const noexcept {
    return traits().is_constexpr;
  }

  immediate bool is_inline() const noexcept {
    return traits().is_inline;
  }
};

/// Compile-time information about a member function.
struct member_function_info {
  meta_data data;

  static constexpr construct_kind construct = member_function_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x3),
        is_static(n & 0x04),
        is_constexpr(n & 0x08),
        is_virtual(n & 0x10),
        is_pure(n & 0x20),
        is_override(n & 0x40),
        is_final(n & 0x80),
        is_defined(n & 0x0100),
        is_deleted(n & 0x0200),
        is_inline(n & 0x0400)
    { }

    unsigned access : 2;
    bool is_static : 1;
    bool is_constexpr : 1;
    bool is_virtual : 1;
    bool is_pure : 1;
    bool is_override : 1;
    bool is_final : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_inline : 1;
  };

  immediate member_function_info() = default;

  immediate member_function_info(meta_info mi)
    : data(mi.is_member_function() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_static() const noexcept {
    return traits().is_static;
  }

  immediate bool is_constexpr() const {
    return traits().is_constexpr;
  }

  immediate bool is_virtual() const {
    return traits().is_virtual;
  }

  immediate bool is_pure_virtual() const {
    return traits().is_pure;
  }

  immediate bool is_override() const {
    return traits().is_override;
  }

  immediate bool is_final() const {
    return traits().is_final;
  }

  immediate bool is_defined() const {
    return traits().is_defined;
  }

  immediate bool is_deleted() const {
    return traits().is_deleted;
  }

  immediate bool is_inline() const {
    return traits().is_inline;
  }
};

/// Compile-time information about a constructor.
struct constructor_info {
  meta_data data;

  static constexpr construct_kind construct = constructor_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03),
        is_explicit(n & 0x40),
        is_constexpr(n & 0x80),
        is_defined(n & 0x0100),
        is_deleted(n & 0x0200),
        is_defaulted(n & 0x0400),
        is_inline(n & 0x0800)
    { }

    unsigned access : 2;
    bool is_explicit : 1;
    bool is_constexpr : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_defaulted : 1;
    bool is_inline : 1;
  };

  immediate constructor_info() = default;

  immediate constructor_info(meta_info mi)
    : data(mi.is_constructor() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_explicit() const {
    return traits().is_explicit;
  }

  immediate bool is_constexpr() const {
    return traits().is_constexpr;
  }

  immediate bool is_defined() const {
    return traits().is_defined;
  }

  immediate bool is_deleted() const {
    return traits().is_deleted;
  }

  immediate bool is_defaulted() const {
    return traits().is_defaulted;
  }

  immediate bool is_inline() const {
    return traits().is_inline;
  }};

/// Compile-time information about a destructor.
struct destructor_info {
  meta_data data;

  static constexpr construct_kind construct = destructor_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03), 
        is_virtual(n & 0x10),
        is_pure(n & 0x20),
        is_override(n & 0x40),
        is_final(n & 0x80),
        is_defined(n & 0x0200),
        is_deleted(n & 0x0400),
        is_defaulted(n & 0x0400),
        is_inline(n & 0x0800)
    { }

    unsigned access : 2;
    bool is_virtual : 1;
    bool is_pure : 1;
    bool is_override : 1;
    bool is_final : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_defaulted : 1;
    bool is_inline : 1;
  };

  immediate destructor_info() = default;

  immediate destructor_info(meta_info mi)
    : data(mi.is_destructor() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_virtual() const {
    return traits().is_virtual;
  }

  immediate bool is_pure_virtual() const {
    return traits().is_pure;
  }

  immediate bool is_override() const {
    return traits().is_override;
  }

  immediate bool is_final() const {
    return traits().is_final;
  }

  immediate bool is_defined() const {
    return traits().is_defined;
  }

  immediate bool is_deleted() const {
    return traits().is_deleted;
  }

  immediate bool is_defaulted() const {
    return traits().is_deleted;
  }

  immediate bool is_inline() const {
    return traits().is_inline;
  }
};

/// Compile-time information about a conversion function.
struct conversion_info {
  meta_data data;

  static constexpr construct_kind construct = conversion_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03),
        is_explicit(n & 0x08),
        is_constexpr(n & 0x10),
        is_virtual(n & 0x20),
        is_pure(n & 0x40),
        is_override(n & 0x80),
        is_final(n & 0x0100),
        is_defined(n & 0x0400),
        is_deleted(n & 0x0800),
        is_inline(n & 0x01000)
    { }

    unsigned access : 2;
    bool is_explicit : 1;
    bool is_constexpr : 1;
    bool is_virtual : 1;
    bool is_pure : 1;
    bool is_override : 1;
    bool is_final : 1;
    bool is_defined : 1;
    bool is_deleted : 1;
    bool is_inline : 1;
  };

  immediate conversion_info() = default;

  immediate conversion_info(meta_info mi)
    : data(mi.is_conversion() ? mi.data : mi.null)
  { }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }
};

/// Compile-time information about an enumeration.
///
/// \todo Add support for underlying type.
struct enum_info {
  meta_data data;

  static constexpr construct_kind construct = enum_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2),
        is_complete(n & 0x10),
        is_scoped(n & 0x20)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
    bool is_complete : 1;
    bool is_scoped : 1;
  };

  immediate enum_info() = default;
  
  immediate enum_info(meta_info mi)
    : data(mi.is_enum() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate member_range members() const noexcept {
    return {*this};
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  immediate bool is_complete() const noexcept {
    return traits().is_complete;
  }

  immediate bool is_scoped() const noexcept {
    return traits().is_scoped;
  }
};

/// Compile-time information about an enumerator.
struct enumerator_info {
  meta_data data;

  static constexpr construct_kind construct = enumerator_decl;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : linkage(n & 0x03),
        access((n & 0x0c) >> 2)
    { }
    
    unsigned linkage : 2;
    unsigned access : 2;
  };

  immediate enumerator_info() = default;

  immediate enumerator_info(meta_info mi)
    : data(mi.is_enumerator() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }

  immediate meta_info type() const noexcept {
    return __reflect_type(data);
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate linkage_kind linkage() const noexcept {
    return linkage_kind(traits().linkage);
  }

  immediate bool has_linkage() const noexcept {
    return linkage() != no_linkage;
  }

  immediate bool has_external_linkage() const noexcept {
    return linkage() == external_linkage;
  }

  immediate bool has_internal_linkage() const noexcept {
    return linkage() == internal_linkage;
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  };

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }

  template<typename T>
  immediate T value() const noexcept {
    T val{};
    (void)__reflect_value(data, val);
    return val;
  }
};

/// Compile-time information about an access specifier.
struct access_info {
  meta_data data;

  static constexpr construct_kind construct = access_spec;

  struct traits_type {
    immediate explicit traits_type(unsigned n) 
      : access(n & 0x03)
    { }
    
    unsigned access : 2;
  };

  immediate access_info() = default;

  immediate access_info(meta_info mi)
    : data(mi.is_access_specifier() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate traits_type traits() const noexcept {
    return traits_type(__reflect_traits(data));
  }

  immediate access_kind access() const noexcept {
    return access_kind(traits().access);
  }

  immediate bool is_public() const noexcept {
    return access() == public_access;
  }

  immediate bool is_private() const noexcept {
    return access() == private_access;
  }

  immediate bool is_protected() const noexcept {
    return access() == protected_access;
  }
};


// -------------------------------------------------------------------------- //
// Types

/// Compile-time information about the void type.
struct void_type_info {
  meta_data data;

  static constexpr construct_kind construct = void_type;

  immediate void_type_info() = default;

  immediate void_type_info(meta_info mi)
    : data(mi.is_void_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a character type.
struct character_type_info {
  meta_data data;

  static constexpr construct_kind construct = character_type;

  immediate character_type_info() = default;

  immediate character_type_info(meta_info mi)
    : data(mi.is_character_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about an integral type.
struct integral_type_info {
  meta_data data;

  static constexpr construct_kind construct = integral_type;

  immediate integral_type_info() = default;

  immediate integral_type_info(meta_info mi)
    : data(mi.is_integral_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a floating point type.
struct floating_point_type_info {
  meta_data data;

  static constexpr construct_kind construct = floating_point_type;

  immediate floating_point_type_info() = default;

  immediate floating_point_type_info(meta_info mi)
    : data(mi.is_floating_point_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a reference type.
struct reference_type_info {
  meta_data data;

  static constexpr construct_kind construct = reference_type;

  immediate reference_type_info() = default;

  immediate reference_type_info(meta_info mi)
    : data(mi.is_reference_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a function type.
struct function_type_info {
  meta_data data;

  static constexpr construct_kind construct = function_type;

  immediate function_type_info() = default;

  immediate function_type_info(meta_info mi)
    : data(mi.is_function_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a pointer type.
struct pointer_type_info {
  meta_data data;

  static constexpr construct_kind construct = pointer_type;

  immediate pointer_type_info() = default;

  immediate pointer_type_info(meta_info mi)
    : data(mi.is_pointer_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

/// Compile-time information about a array type.
struct array_type_info {
  meta_data data;

  static constexpr construct_kind construct = array_type;

  immediate array_type_info() = default;

  immediate array_type_info(meta_info mi)
    : data(mi.is_array_type() ? mi.data : mi.null)
  { }

  immediate operator meta_info() const noexcept {
    return meta_info(data);
  }

  immediate explicit operator bool() const noexcept { 
    return has_value(); 
  }

  immediate bool has_value() const noexcept { 
    return !data.null(); 
  }

  immediate const char* name() const noexcept {
    return __reflect_name(data);
  }
};

// -------------------------------------------------------------------------- //
// Construct kind

template<> 
struct construct_type<translation_unit> { using type = translation_info; };
template<> 
struct construct_type<namespace_decl> { using type = namespace_info; };
template<> 
struct construct_type<variable_decl> { using type = variable_info; };
template<> 
struct construct_type<function_decl> { using type = function_info; };
template<> 
struct construct_type<parameter_decl> { using type = parameter_info; };
template<> 
struct construct_type<class_decl> { using type = class_info; };
template<> 
struct construct_type<union_decl> { using type = union_info; };
template<> 
struct construct_type<member_variable_decl> { using type = member_variable_info; };
template<> 
struct construct_type<member_function_decl> { using type = member_function_info; };
template<> 
struct construct_type<enum_decl> { using type = enum_info; };
template<> 
struct construct_type<enumerator_decl> { using type = enumerator_info; };
template<> 
struct construct_type<access_spec> { using type = access_info; };

template<> 
struct construct_type<void_type> { using type = void_type_info; };
template<> 
struct construct_type<character_type> { using type = character_type_info; };
template<> 
struct construct_type<integral_type> { using type = integral_type_info; };
template<> 
struct construct_type<floating_point_type> { using type = floating_point_type_info; };
template<> 
struct construct_type<reference_type> { using type = reference_type_info; };
template<> 
struct construct_type<function_type> { using type = function_type_info; };
template<> 
struct construct_type<pointer_type> { using type = pointer_type_info; };
template<> 
struct construct_type<array_type> { using type = array_type_info; };


// -------------------------------------------------------------------------- //
// Definitions

immediate bool is_member_variable_p::operator()(meta_info mi) const noexcept {
  return mi.is_member_variable();
}

immediate bool is_instance_variable_p::operator()(meta_info mi) const noexcept {
  if (member_variable_info var = mi)
    return !var.is_static();
  return false;
}

immediate bool is_class_variable_p::operator()(meta_info mi) const noexcept {
  if (member_variable_info var = mi)
    return var.is_static();
  return false;
}

immediate bool is_member_function_p::operator()(meta_info mi) const noexcept {
  return mi.is_member_function() || 
         mi.is_constructor() || 
         mi.is_destructor() ||
         mi.is_conversion();
}

immediate bool is_instance_function_p::operator()(meta_info mi) const noexcept {
  if (member_function_info fn = mi)
    return !fn.is_static();
  return mi.is_constructor() || mi.is_destructor() || mi.is_conversion();
}

immediate bool is_constructor_p::operator()(meta_info mi) const noexcept {
  return mi.is_constructor();
}

immediate bool is_destructor_p::operator()(meta_info mi) const noexcept {
  return mi.is_destructor();
}

immediate bool is_class_function_p::operator()(meta_info mi) const noexcept {
  if (member_function_info fn = mi)
    return fn.is_static();
  return false;
}

immediate memvar_range class_info::all_member_variables() const noexcept {
  return {*this};
}

immediate instance_memvar_range class_info::member_variables() const noexcept {
  return {*this};
}

immediate class_memvar_range class_info::static_member_variables() const noexcept {
  return {*this};
}

immediate memfun_range class_info::all_member_functions() const noexcept {
  return {*this};
}

immediate constructor_range class_info::constructors() const noexcept {
  return {*this};
}

immediate destructor_range class_info::destructors() const noexcept {
  return {*this};
}

immediate class_memfun_range class_info::static_member_functions() const noexcept {
  return {*this};
}


// -------------------------------------------------------------------------- //
// Utilities

struct compiler_type {
  static immediate void print(const char* str) noexcept {
    (void)__reflect_print(str);
  }

  template<typename T>
  static immediate std::enable_if_t<std::is_integral_v<T>, void>
  print(T n) noexcept {
    (void)__reflect_print(n);
  }

  // Specialization for reflected types.
  template<typename T>
  static immediate std::enable_if_t<T::construct != 0, void>
  print(T info) noexcept {
    (void)__reflect_print(info.data);
  }
} compiler;


} // inline namespace v1
} // namespace meta
} // namespace cppx



#endif // CPPX_META
